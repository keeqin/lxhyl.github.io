# 判断一个数是否是4的幂次方

4的幂次方一定是2的幂次方，所有先开根号，判断是否是整数，然后再判断是否是2的幂次方
```js
const fun = n => {
    const sqrt = Math.sqrt(n)
    return (Number.isInteger(sqrt) && sqrt > 0) ? (sqrt & sqrt - 1) === 0 : false 
}
```

# 160. 相交链表  

遍历a链表，将每个节点存储，然后遍历b链表，找出相同的节点
```js
const getNode = (headA,headB) => {
      const mapObj = new Set()
      let tempNode = headA
      while(tempNode){
          mapObj.add(tempNode)
          tempNode = tempNode.next
      }
      tempNode = headB
      while(tempNode){
          if(mapObj.has(tempNode)){
              return tempNode
          }
          tempNode = tempNode.next
      }
      return null
}
```

# 852. 山脉数组的峰顶索引  
```js
const peakIndexInMountainArray = arr => {
    let i = 0
    while(i < arr.length - 1 && arr[i] < arr[i + 1]){
        i++
    }
    return i
}
```

# 94. 二叉树的中序遍历
```js
const inorderTraversal = root => {
    const result = []
    const helper = node => {
        if(!node) return
        helper(node.left)
        result.push(node.val)
        helper(node.right)
    }
    helper(root)
    return result;
}
```


# 98. 验证二叉搜索树

二叉搜索树中序遍历得到有序数组，利用双指针判断数组是否是单调递增的，如果递增，则说明是二叉搜索树
```js
const isValidBST = root => {
    const valArr = []
    const dfs = node => {
        if(!node) return
        dfs(node.left)
        valArr.push(node.val)
        dfs(node.right)
    }
    dfs(root)
    let i=0,j=1;
    if(valArr.length <= 1) return true
    while(i < j && j < valArr.length){
        if(valArr[i] < valArr[j]){
            i++
            j++
        }else{
            return false
        }
    }
    return true
}
```


# 102.二叉树的层序遍历
递归函数的参数为每一层的节点集合
```js
const levelOrder = root => {
    const result = []
    const lsfHelper = nodesArr => {
        if (nodesArr.length === 0) return
        const tempLevelArr = []
        const tempNodeArr = []
        nodesArr.forEach(itemNode => {
            if (!itemNode) return
            tempLevelArr.push(itemNode.val)
            tempNodeArr.push(itemNode.left)
            tempNodeArr.push(itemNode.right)
        });
        if (tempLevelArr.length > 0) {
            result.push([...tempLevelArr])
        }
        lsfHelper(tempNodeArr)
    }
    lsfHelper([root])
    return result
}
```


# 103.二叉树的锯齿形遍历

只需要在层序遍历的基础上，递归函数加个第几层的参数，然后判断层数的奇偶性来判断
```js
const levelOrder = root => {
    const result = []
    const lsfHelper = (nodesArr,level) => {
        if (nodesArr.length === 0) return
        const tempLevelArr = []
        const tempNodeArr = []
        nodesArr.forEach(itemNode => {
            if (!itemNode) return
            tempLevelArr.push(itemNode.val)
            tempNodeArr.push(itemNode.left)
            tempNodeArr.push(itemNode.right)
        });
        if (tempLevelArr.length > 0) {
            if(level % 2 === 0){
                result.push([...tempLevelArr].reverse())
            }else{
                result.push([...tempLevelArr])
            }
        }
        lsfHelper(tempNodeArr,level + 1)
    }
    lsfHelper([root],1)
    return result
}
```

# 104.二叉树的最大深度

```js
const maxDepth = root => {
    const dfs = node => {
        if(!node) return 0
        return Math.max(dfs(node.left),dfs(node.right)) + 1
    }
    return dfs(root)
}
```

# 107.二叉树的层序遍历2
```js
const orderTree = root => {
    const result = []
    const lsfHelper = nodesArr => {
        if (nodesArr.length === 0) return
        const tempLevelArr = []
        const tempNodeArr = []
        nodesArr.forEach(itemNode => {
            if (!itemNode) return
            tempLevelArr.push(itemNode.val)
            tempNodeArr.push(itemNode.left)
            tempNodeArr.push(itemNode.right)
        });
        if (tempLevelArr.length > 0) {
            result.unshift([...tempLevelArr])
        }
        lsfHelper(tempNodeArr)
    }
    lsfHelper([root])
    return result
```


# 1333.餐厅过滤器

```js
const filterRestaurants = function(restaurants, veganFriendly, maxPrice, maxDistance) {
    const filtersArr = restaurants.filter(rest => {
        return rest[3] <= maxPrice && rest[4] <= maxDistance
    }).filter(rest => {
        if(veganFriendly === 1){
            return rest[2] === 1
        }
        return true
    })
    filtersArr.sort((a,b) => {
        if(a[1] < b[1]){
            return 1
        }else if(a[1] === b[1]){
            return b[0] - a[0]
        }else{
            return -1
        }
    })
    return filtersArr.map(item => item[0])
};
```