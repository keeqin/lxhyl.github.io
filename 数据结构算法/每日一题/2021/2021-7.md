# LCP 07.传递信息
```js
const numWays = (n,relation,k) => {
    const allWaysMap = Array(n).fill(null).map(() => Array())
    for(let [start,next] of relation){
        allWaysMap[start].push(next)
    }
    let result = 0;
    const dfs = (index,step) => {
        if(step === k){
            if(index === n -1){
                result++
            }
            return
        }else{
            allWaysMap[index].forEach(item => {
                dfs(item,step + 1)
            })
        }
    }
    dfs(0,0)
    return result
}
```

# 3.无重复字符的最长子串   

> 滑动窗口法 
```js
const lengthOfLongestSubstring = s => {
    const len = s.length
    if(len <= 1) return len
    let i = 0;
    let result = 0
    while(i < len - 1){
        let j = i + 1;
        const set = new Set()
        set.add(s[i])
        while(!set.has(s[j]) && j<len){
            set.add(s[j])
            j++
        }
        let childLen = set.size
        result = childLen > result ? childLen : result
        i++
    }
    return result
}
```

# 1833.雪糕的最大数量  

> 排序加贪心即可

```js
const maxIceCream = (costs,coins) => {
    costs.sort((a,b) => a - b)
    let result = 0;
    for(let i=0; i<costs.length; i++){
        if(coins >= costs[i]){
            result += 1
            coins -= costs[i]
        }else{
            break
        }
    }
    return result
}
```

**Python** 
```python
def maxIceCream(costs,coins):
        costs.sort()
        result = 0
        for cost in costs:
            if cost > coins:
                break
            result += 1
            coins -= cost
        return result
```

**go** 

```go
func maxIceCream(costs []int, coins int) int {
	sort.Ints(costs)
	result := 0
	for _, v := range costs {
		if coins < v {
			break
		}
		result++
		coins -= v
	}
	return result
}
```


# 451.根据字符出现的频率排序  

先统计出每一个字符出现的次数，然后再排序。  

```js
const frequencySort = s => {
    const len = s.length
    if(s.length <= 1) return s
    const strNumMap = {}
    for(let i=0;i<len;i++){
        strNumMap[s[i]] =  strNumMap[s[i]] ?  strNumMap[s[i]] + 1 : 1  
    }
    const strNumArr = []
    for(let key in strNumMap){
        strNumArr.push({
            s:key,
            n:strNumMap[key]
        })
    }
    strNumArr.sort((a,b) => b.n - a.n)
    return strNumArr.map(item => {
            let str = ''
            let i = 1
            while(i <= item.n){
                str += item.s
                i++
            }
            return str
    }).join('')
}
```


# 509.斐波那契数列   

> 动态规划   
要开始动态规划的题目的专项学习了    

* 动态规划重要的特点就是每个子问题只求解一次  

最简单的斐波那契数列为例，`f(n) = f(n-1) = f(n - 2)`为状态转移方程，每一项计算都和前两项有关，所以可以定义个数组存储每次结算的结果，`dp[n]`即为n时的结果，如`dp[0]`就代表`n=0`时的结果，`dp[1]`就代表`n=1`时的结果。  
```js
const fib = n => {
    const dp = []
    dp[0] = 0
    dp[1] = 1
    if(n <= 1) return dp[n]
    let i = 2
    while(i <= n){
        dp[i] = dp[i-1] + dp[i-2]
        i++
    }
    return dp[n]
}
```

# 1137.第n个泰波那契数    

和上面同理

```js
const tribonacci = n => {
    const dp = [0,1,1]
    if(n <= 2) return dp[n]
    let i = 3
    while(i <= n){
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
        i++
    }
    return dp[n]
}
```  

# 645.错误的集合

```js
const findErrorNums = nums => {
    // 存储i和数量
    const numsMap = new Map()
    nums.forEach(item => {
        if(!numsMap.has(item)){
            numsMap.set(item,1)
        }else{
            numsMap.set(item,2)
        }
    })
    let miss,mult
    for(let i=1;i<=nums.length;i++){
        if(!numsMap.has(i)){
            miss = i
        }
        if(numsMap.get(i) === 2){
            mult = i
        }
    }
    return [mult,miss]
}
```

# 70.爬楼梯

状态转移方程 `f(x) = f(x-1) + f(x-2)`    
每次爬楼梯向前一步或两部，所以爬到第`x`层的方法等于`x-1`层的方法加上`x-2`层 

```js
const climbStairs = n => {
    const dp = []
    dp[1] = 1
    dp[2] = 2
    let i = 3
    while(i<=n){
        dp[i] = dp[i-1] + dp[i-2]
        i++
    }
    return dp[n]
}
```

由于只和前两层有关，所以还可以优化空间
```js
const climbStairs = n => {
    let x1=0,x2=0
    let x = 1
    for(let i=1;i<=n;i++){
        x1 = x2
        x2 = x
        x = x1 + x2
    }
    return x
}
```

# 746.使用最小花费爬楼梯 
```js
const minCostClimbingStairs = cost => {
    const len = cost.length
    const dp = Array(len + 1)
    dp[0] = 0
    dp[1] = 0
    let i=2
    while(i <= len){
        dp[i] = Math.min(dp[i-1] + cost[i-1],dp[i-2] + cost[i-2])
        i++
    }
    return dp[len]
}
```

# 198.打家劫舍  

偷到第`x`家的高金额的状态转移方程`f(x) = max(f(x-1), f(x-2) + nums[x])`    
边界条件:`f(0) = nums[0]`,`f(1) = max(nums[0],nums[1])`

```js
const rob =  nums => {
    const len = nums.length
    if(len === 1) return nums[0]
    if(len === 2) return Math.max(nums[0],nums[1])
    const dp = Array(len)
    dp[0] = nums[0]
    dp[1] = Math.max(nums[0],nums[1])
    let i = 2;
    while(i<len){
        dp[i] = Math.max(dp[i-1],dp[i-2] + nums[i])
        i++
    }
    return dp[len-1]
}
```

# 213.打家劫舍2 
增加了判断，看包含第一家不包含最后一家始偷得多，还是包含最后一家不包含第一家偷的多
```js
const rob = nums => {
    const len = nums.length
    if(len === 1) return nums[0]
    if(len === 2) return Math.max(nums[0],nums[1])
    const steal = (start,end) => {
        let first = nums[start]
        let second = Math.max(nums[start],nums[start + 1])
        for(let i = start + 2; i<=end; i++){
            const  t = Math.max(first + nums[i],second)
            first = second
            second = t
        }
        return second
    }
    return Math.max(steal(0,len-2),steal(1,len-1))
}
```

# 740.删除并获得点数

把`num[i]`作为索引，所有等于`num[i]`的数之和作为值。
就相当于打家劫舍的不能连着偷

```js
const deleteAndEarn = nums => {
    const len = nums.len
    if(len === 0) return 0
    if(len === 1) return nums[0]
    const numsCount = {}
    nums.forEach(n => {
        if(n in numsCount){
            numsCount[n] += 1
        }else{
            numsCount[n] = 1
        }
    })
    const numsSum = []
    for(let key in numsCount){
        numsSum[key] = Number(key) * numsCount[key]
    }
    const dp = Array(len)
    dp[0] = numsSum[0] || 0
    dp[1] = Math.max(numsSum[0] || 0,numsSum[1] || 0)
    let i = 2
    while(i < numsSum.length){
        dp[i] = Math.max(dp[i-1],dp[i-2] + numsSum[i] || 0)
        i++
    }
    return dp[numsSum.length - 1]
}
```

# 1418.点菜展示表

就是数据结构的转换，数组转对象再转数组

```js
const displayTable = orders => {
    const tablesObj = {}
    const allProductSet = new Set()
    for(let i=0;i<orders.length;i++){
        [_,tableNum,product] = orders[i]
        allProductSet.add(product)
        if(!tablesObj[tableNum]){
            tablesObj[tableNum] = {}
        }
        if(!tablesObj[tableNum][product]){
            tablesObj[tableNum][product] = 1
        }else{
            tablesObj[tableNum][product]++
        }
    }
    const titles = Array.from(allProductSet).sort()
    titles.unshift('Table')
    const result = [titles]
    for(let table in tablesObj){
        const nums = [table]
        for(let i=1;i<titles.length;i++){
            if(!tablesObj[table][titles[i]]){
                nums.push("0")
            }else{
                nums.push(tablesObj[table][titles[i]].toString())
            }
        }
        result.push(nums)
    }
    return result
}
```