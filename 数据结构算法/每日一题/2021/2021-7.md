# LCP 07.传递信息
```js
const numWays = (n,relation,k) => {
    const allWaysMap = Array(n).fill(null).map(() => Array())
    for(let [start,next] of relation){
        allWaysMap[start].push(next)
    }
    let result = 0;
    const dfs = (index,step) => {
        if(step === k){
            if(index === n -1){
                result++
            }
            return
        }else{
            allWaysMap[index].forEach(item => {
                dfs(item,step + 1)
            })
        }
    }
    dfs(0,0)
    return result
}
```

# 3.无重复字符的最长子串   

> 滑动窗口法 
```js
const lengthOfLongestSubstring = s => {
    const len = s.length
    if(len <= 1) return len
    let i = 0;
    let result = 0
    while(i < len - 1){
        let j = i + 1;
        const set = new Set()
        set.add(s[i])
        while(!set.has(s[j]) && j<len){
            set.add(s[j])
            j++
        }
        let childLen = set.size
        result = childLen > result ? childLen : result
        i++
    }
    return result
}
```

# 1833.雪糕的最大数量  

> 排序加贪心即可

```js
const maxIceCream = (costs,coins) => {
    costs.sort((a,b) => a - b)
    let result = 0;
    for(let i=0; i<costs.length; i++){
        if(coins >= costs[i]){
            result += 1
            coins -= costs[i]
        }else{
            break
        }
    }
    return result
}
```

**Python** 
```python
def maxIceCream(costs,coins):
        costs.sort()
        result = 0
        for cost in costs:
            if cost > coins:
                break
            result += 1
            coins -= cost
        return result
```

**go** 

```go
func maxIceCream(costs []int, coins int) int {
	sort.Ints(costs)
	result := 0
	for _, v := range costs {
		if coins < v {
			break
		}
		result++
		coins -= v
	}
	return result
}
```


# 451.根据字符出现的频率排序  

先统计出每一个字符出现的次数，然后再排序。  

```js
const frequencySort = s => {
    const len = s.length
    if(s.length <= 1) return s
    const strNumMap = {}
    for(let i=0;i<len;i++){
        strNumMap[s[i]] =  strNumMap[s[i]] ?  strNumMap[s[i]] + 1 : 1  
    }
    const strNumArr = []
    for(let key in strNumMap){
        strNumArr.push({
            s:key,
            n:strNumMap[key]
        })
    }
    strNumArr.sort((a,b) => b.n - a.n)
    return strNumArr.map(item => {
            let str = ''
            let i = 1
            while(i <= item.n){
                str += item.s
                i++
            }
            return str
    }).join('')
}
```


# 509.斐波那契数列   

> 动态规划   
要开始动态规划的题目的专项学习了    

* 动态规划重要的特点就是每个子问题只求解一次  

最简单的斐波那契数列为例，`f(n) = f(n-1) = f(n - 2)`为状态转移方程，每一项计算都和前两项有关，所以可以定义个数组存储每次结算的结果，`dp[n]`即为n时的结果，如`dp[0]`就代表`n=0`时的结果，`dp[1]`就代表`n=1`时的结果。  
```js
const fib = n => {
    const dp = []
    dp[0] = 0
    dp[1] = 1
    if(n <= 1) return dp[n]
    let i = 2
    while(i <= n){
        dp[i] = dp[i-1] + dp[i-2]
        i++
    }
    return dp[n]
}
```

# 1137.第n个泰波那契数    

和上面同理

```js
const tribonacci = n => {
    const dp = [0,1,1]
    if(n <= 2) return dp[n]
    let i = 3
    while(i <= n){
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
        i++
    }
    return dp[n]
}
```  

# 645.错误的集合

```js
const findErrorNums = nums => {
    // 存储i和数量
    const numsMap = new Map()
    nums.forEach(item => {
        if(!numsMap.has(item)){
            numsMap.set(item,1)
        }else{
            numsMap.set(item,2)
        }
    })
    let miss,mult
    for(let i=1;i<=nums.length;i++){
        if(!numsMap.has(i)){
            miss = i
        }
        if(numsMap.get(i) === 2){
            mult = i
        }
    }
    return [mult,miss]
}
```

# 70.爬楼梯

状态转移方程 `f(x) = f(x-1) + f(x-2)`    
每次爬楼梯向前一步或两部，所以爬到第`x`层的方法等于`x-1`层的方法加上`x-2`层 

```js
const climbStairs = n => {
    const dp = []
    dp[1] = 1
    dp[2] = 2
    let i = 3
    while(i<=n){
        dp[i] = dp[i-1] + dp[i-2]
        i++
    }
    return dp[n]
}
```

由于只和前两层有关，所以还可以优化空间
```js
const climbStairs = n => {
    let x1=0,x2=0
    let x = 1
    for(let i=1;i<=n;i++){
        x1 = x2
        x2 = x
        x = x1 + x2
    }
    return x
}
```

# 746.使用最小花费爬楼梯 
```js
const minCostClimbingStairs = cost => {
    const len = cost.length
    const dp = Array(len + 1)
    dp[0] = 0
    dp[1] = 0
    let i=2
    while(i <= len){
        dp[i] = Math.min(dp[i-1] + cost[i-1],dp[i-2] + cost[i-2])
        i++
    }
    return dp[len]
}
```