# LCP 07.传递信息
```js
const numWays = (n,relation,k) => {
    const allWaysMap = Array(n).fill(null).map(() => Array())
    for(let [start,next] of relation){
        allWaysMap[start].push(next)
    }
    let result = 0;
    const dfs = (index,step) => {
        if(step === k){
            if(index === n -1){
                result++
            }
            return
        }else{
            allWaysMap[index].forEach(item => {
                dfs(item,step + 1)
            })
        }
    }
    dfs(0,0)
    return result
}
```

# 3.无重复字符的最长子串   

> 滑动窗口法 
```js
const lengthOfLongestSubstring = s => {
    const len = s.length
    if(len <= 1) return len
    let i = 0;
    let result = 0
    while(i < len - 1){
        let j = i + 1;
        const set = new Set()
        set.add(s[i])
        while(!set.has(s[j]) && j<len){
            set.add(s[j])
            j++
        }
        let childLen = set.size
        result = childLen > result ? childLen : result
        i++
    }
    return result
}
```

# 1833.雪糕的最大数量  

> 排序加贪心即可

```js
const maxIceCream = (costs,coins) => {
    costs.sort((a,b) => a - b)
    let result = 0;
    for(let i=0; i<costs.length; i++){
        if(coins >= costs[i]){
            result += 1
            coins -= costs[i]
        }else{
            break
        }
    }
    return result
}
```

**Python** 
```python
def maxIceCream(costs,coins):
        costs.sort()
        result = 0
        for cost in costs:
            if cost > coins:
                break
            result += 1
            coins -= cost
        return result
```

**go** 

```go
func maxIceCream(costs []int, coins int) int {
	sort.Ints(costs)
	result := 0
	for _, v := range costs {
		if coins < v {
			break
		}
		result++
		coins -= v
	}
	return result
}
```


# 451.根据字符出现的频率排序  

先统计出每一个字符出现的次数，然后再排序。  

```js
const frequencySort = s => {
    const len = s.length
    if(s.length <= 1) return s
    const strNumMap = {}
    for(let i=0;i<len;i++){
        strNumMap[s[i]] =  strNumMap[s[i]] ?  strNumMap[s[i]] + 1 : 1  
    }
    const strNumArr = []
    for(let key in strNumMap){
        strNumArr.push({
            s:key,
            n:strNumMap[key]
        })
    }
    strNumArr.sort((a,b) => b.n - a.n)
    return strNumArr.map(item => {
            let str = ''
            let i = 1
            while(i <= item.n){
                str += item.s
                i++
            }
            return str
    }).join('')
}
```